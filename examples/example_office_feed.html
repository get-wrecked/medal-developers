<html>


<head>

    <title>Office Feed Example</title>

    <link href="https://fonts.googleapis.com/css?family=Gudea:400,500,600,700|Rajdhani:300,400,500,600,700&amp;subset=devanagari,latin-ext" rel="stylesheet">
    <style>

        .description {
            flex: 0.1;
            height: 15px;
            color: goldenrod;
            font-family: 'Rajdhani', sans-serif;
        }

        .credits {
            flex: 0.1;
            height: 15px;
        }

        h1 {
            color: white;
        }

        .feed-clip {
            display: flex;
            justify-content: center;
            height: 400px;
            padding: 20px;
            width: 560px;
            flex-direction: column;
        }

        .feed-clip iframe {
            overflow: hidden;
            border-radius: 20px;
        }

        body {
            background: #212121;

        }

        .title {
            font-size;: 19,
        }

        .clip-row {
            display: flex;
            align-items: center;
            flex-direction: row;
            height: 50%;
        }

        .page-container {
            padding: 100px;
        }

        .page-container a {
            color: white;
            font-size: 1.2em;
            margin: 0 20px;
        }
    </style>
</head>
<body>
<div class="clip-row" id="trending"></div>
<div class="clip-row" id="latest"></div>

<script>


    const urlParams = new URLSearchParams(window.location.search);
    const categoryId = urlParams.get('categoryId') || 62;
    const trendingRefreshRate = urlParams.get('trendingRefreshRate') || 15000;
    const latestRefreshRate = urlParams.get('latestRefreshRate') || 15000;


    // map to avoid duplicate content from being shown. If a conflict is detected, we'll render another object.
    let existingCache = {};


    // keep going down trending feed on top one.
    let trendingOffset = 2; // start with 2.

    const PUBLIC_API_KEY = 'pub_6amR5ZEL8V6MB9IY3lomzeyFyLqrhQw2';

    function populate(json, el) {

        const {contentObjects} = json;

        for (const clip of contentObjects) {
            if(!valid(clip)) {
                continue;
            }
            const clipEl = document.createElement("div");
            clipEl.className = "feed-clip";
            clipEl.innerHTML = `<p align="left" class="description">${el === 'trending' ? ("<b>Trending: </b>"+clip.contentTitle) : (timeAgo(clip.createdTimestamp) + " - " + clip.contentTitle)} </p><br/>${clip.embedIframeCode}<br/>`;
            document.getElementById(el).insertBefore(clipEl, document.getElementById(el).childNodes[0]);
            existingCache[clip.contentId] = true;
        }

    }

    function addTo(json, el) {

        console.log(existingCache);

        const {contentObjects} = json;

        for (const clip of contentObjects) {
            if(!valid(clip)) {
                continue;
            }
            if(existingCache[clip.contentId] === undefined) {
                const clipEl = document.createElement("div");
                clipEl.className = "feed-clip";
                clipEl.innerHTML = `<p align="left" class="description">${el === 'trending' ? ("<b>Trending: </b>"+clip.contentTitle) : (timeAgo(clip.createdTimestamp) + " - " + clip.contentTitle)} </p><br/>${clip.embedIframeCode}<br/>`;
                document.getElementById(el).insertBefore(clipEl, document.getElementById(el).childNodes[0]);
                try {
                    document.getElementById(el).removeChild(document.getElementById(el).childNodes[3])
                } catch(err) {C
                    // swallow
                }
            } else {

                // get a new one with offset + previous offset
                if(el === 'trending') {

                    trendingOffset += 1; // increase offset by 1 to keep going down trending feed


                    fetch(`https://developers.medal.tv/v1/trending?categoryId=${categoryId}&muted=1&height=400&width=560&limit=1&autoplay=1&muted=1&offset=${trendingOffset}`, {
                        headers: {
                            'Authorization': PUBLIC_API_KEY
                        }
                    })
                        .then(function (response) {
                            console.log(response);
                            return response.json();
                        })
                        .then(function (myJson) {
                            this.addTo(myJson, "trending");
                        });
                }
            }
            existingCache[clip.contentId] = true;
        }

    }


    function checkForLatest() {

        setInterval(function () {
            fetch(`https://developers.medal.tv/v1/latest?categoryId=${categoryId}&muted=1&height=400&width=560&limit=1&muted=1&autoplay=1`, {
                headers: {
                    'Authorization': PUBLIC_API_KEY
                }
            })
                .then(function (response) {
                    console.log(response);
                    return response.json();
                })
                .then(function (myJson) {
                    this.addTo(myJson, "latest");
                });
        }, refreshRate) // check latest every 15 seconds. If there is no newer content, go to 1 older

    }

    function valid(clip) {
        console.log(clip);
        return clip.videoLengthSeconds > 1;
    }
    function checkForTrending() {

        setInterval(function () {
            fetch(`https://developers.medal.tv/v1/trending?categoryId=${categoryId}&muted=1&height=400&width=560&muted=1&limit=1&autoplay=1`, {
                headers: {
                    'Authorization': PUBLIC_API_KEY
                }
            })
                .then(function (response) {
                    console.log(response);
                    return response.json();
                })
                .then(function (myJson) {
                    this.addTo(myJson, "trending");
                });
        }, refreshRate) // check trending every 15 seconds. If there is no hotter content, go to 1 less hot

    }

    fetch(`https://developers.medal.tv/v1/latest?categoryId=${categoryId}&muted=1&height=400&width=560&muted=1&limit=2&autoplay=1`, {
        headers: {
            'Authorization': PUBLIC_API_KEY
        }
    })
        .then(function (response) {
            console.log(response);
            return response.json();
        })
        .then(function (myJson) {
            this.populate(myJson, "latest");
            this.checkForLatest();
        });


    fetch(`https://developers.medal.tv/v1/trending?categoryId=${categoryId}&muted=1&height=400&width=560&muted=1&limit=2&autoplay=1`, {
        headers: {
            'Authorization': PUBLIC_API_KEY
        }
    })
        .then(function (response) {
            console.log(response);
            return response.json();
        })
        .then(function (myJson) {
            this.populate(myJson, "trending");
            this.checkForTrending();
        });


    const NOW = new Date()
    const times = [["second", 1], ["minute", 60], ["hour", 3600], ["day", 86400], ["week", 604800], ["month", 2592000], ["year", 31536000]]

    function timeAgo(date) {
        var diff = Math.round((NOW - date) / 1000)
        for (var t = 0; t < times.length; t++) {
            if (diff < times[t][1]) {
                if (t == 0) {
                    return "Just now"
                } else {
                    diff = Math.round(diff / times[t - 1][1])
                    return diff + " " + times[t - 1][0] + (diff == 1?" ago":"s ago")
                }
            }
        }
    }


</script>
</body>
</html>
